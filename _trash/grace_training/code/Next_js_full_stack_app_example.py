# Source: https://github.com/xizon/fullstack-nextjs-app-template
# Term: Next.js full stack app

pages

npm run export

npm run export:fix

socket.io

fullstack-nextjs-app-template/
├── README.md
├── CHANGELOG.md
├── LICENSE
├── next.config.js
├── server.js
├── ecosystem.config.js
├── middleware.ts
├── tsconfig.json
├── package-lock.json
├── package.json 
├── .dockerignore
├── Dockerfile
├── docker-compose.yml
├── out/                # Folder generated by export command which contains the HTML/CSS/JS assets for your application
├── backend@nest/       # NestJS server
├── backend/            # Express server
│   ├── server-php.js 
│   └── ...             # All other files are optional
├── scripts/            # Node Script Library
├── public/             # Contains static resources, PHP remote test files, .md files for markdown rendering, etc.
├── app/                # App Router Demo Template
├── @pages/             # Pages Router Demo Template (Enabling it requires renaming the folder `@pages` to `pages`, and deleting `app`.)
│   ├── api/
│   └── *.tsx
├── src/
│   ├── config/
│   ├── data/
│   ├── contexts/
│   ├── interfaces/
│   ├── components/
│   ├── styles/
│   ├── utils/
│   └── store/
└──

$ npm install

node_module

$ npm i next@latest react@latest react-dom@latest eslint-config-next@latest

$ npm run dev & npm run action:phpserver  

$ npm run build 

$ npm run build:static 

$ npm run start

Express

$ npm run action:phpserver

NestJS

./backend@nest/__.zip

$ cd backend@nest

# generate an executable file (you can run "npm run action:phpserver:nest")
$ npm run build

# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod

./backend/server-php.js

./backend@nest/dist/main.js

$ npm run build  # this command must be run first
$ npm run deploy:prod 

$ npm run deploy:dev 

$ npm run destroy

$ npm run export

$ npm run export:fix

.out/

$ npm run export:test

import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
    return (
    <Html>
        <Head />
        <body>
        <Main />
        <NextScript />
        </body>
    </Html>
    )
}

<Html>

</Html>

<html>

</html>

<html lang="en">

<Head>

</Head>

<head>

</head>

<Head />

<Main />

{children}

{children}

children

React.ReactNode

<NextScript />

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
    <html lang="en">
        <body>{children}</body>
    </html>
    )
}

import type { AppProps } from 'next/app'

export default function MyApp({ Component, pageProps }: AppProps) {
    return <Component {...pageProps} />
}

"use client"

Component

pageProps

children

children

React.ReactNode

<Component {...pageProps} />

<>{children}</>

{children}

pageProps

pageProps

MyApp

ClientLayout

'use client'

export default function ClientLayout({ children }: { children: React.ReactNode }) {
    return <>{children}</>
}

ClientLayout

{children}

import ClientLayout from './ClientLayout'

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
    <html lang="en">
        <body>
        <ClientLayout>{children}</ClientLayout>
        </body>
    </html>
    )
}

import ClientPage from './ClientPage'

export default async function Page() {
    return <ClientPage />
}

getStaticProps

export const getStaticProps: GetStaticProps<PageProps> = async () => {
    const res = await fetch('https://api.github.com/repos/vercel/next.js')
    const repo = await res.json()
    return { props: { repo } }
}

getStaticProps

getStaticProps

Page

export const dynamic = "force-static"

ClientPage

import ClientPage from './ClientPage'

export const getStaticProps: GetStaticProps<PageProps> = async () => {
    const res = await fetch('https://api.github.com/repos/vercel/next.js')
    const repo = await res.json()
    return { props: { repo } }
}

export const dynamic = 'force-static'

export default async function Page() {
    const { props } = await getStaticProps()
    return <ClientPage {...props} />
}

getServerSideProps

import { getAuth } from '@clerk/nextjs/server'

export const getServerSideProps: GetServerSideProps<PageProps> = async ({ req }) => {
    const { userId } = getAuth(req)

    const res = await fetch('https://api.example.com/foo', {
    headers: {
        Authorization: `Bearer: ${process.env.API_KEY}`,
    },
    })
    const data = await res.json()
    return { props: { data } }
}

getServerSideProps

export const dynamic = "force-dynamic"

req

req.headers

req.cookies

req.url.searchParams

getServerSideProps

Page

ClientPage

import { auth } from '@clerk/nextjs'
import ClientPage from './ClientPage'

export const getServerSideProps: GetServerSideProps<PageProps> = async () => {
    const { userId } = auth()

    const res = await fetch('https://api.example.com/foo', {
    headers: {
        Authorization: `Bearer: ${process.env.API_KEY}`,
    },
    })
    const data = await res.json()
    return { props: { data } }
}

export const dynamic = 'force-dynamic'

export default async function Page() {
    const { props } = await getServerSideProps()
    return <ClientPage {...props} />
}

getStaticPaths

export async function getStaticPaths() {
    return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
    }
}

generateStaticParams

getStaticProps

import ClientPage from './ClientPage'

export async function getStaticPaths() {
    return {
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
    }
}

export async function generateStaticParams() {
    const staticPaths = await getStaticPaths()
    return staticPaths.paths.map((x) => x.params)
}

export const getStaticProps: GetStaticProps<PageProps> = async ({ params }) => {
    const res = await fetch(`https://api.example.com/foo/${params.id}`)
    const data = await res.json()
    return { props: { data } }
}

export default async function Page({ params }) {
    const { props } = await getStaticProps({ params })
    return <ClientPage {...props} />
}

server.js

.ts

pages

const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');

let dev = process.env.NODE_ENV !== 'production';
dev = false;  // need run `npm run build` first
const hostname = 'localhost';
const port = 3000;
// when using middleware `hostname` and `port` must be provided below
const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

app.prepare().then(() => {
  createServer(async (req, res) => {
    try {
      // Be sure to pass `true` as the second argument to `url.parse`.
      // This tells it to parse the query portion of the URL.
      const parsedUrl = parse(req.url, true)
      const { pathname, query } = parsedUrl

      if (pathname === '/a') {
        await app.render(req, res, '/a', query)
      } else if (pathname === '/b') {
        await app.render(req, res, '/b', query)
      } else {
        await handle(req, res, parsedUrl)
      }
      
    } catch (err) {
      console.error('Error occurred handling', req.url, err)
      res.statusCode = 500
      res.end('internal server error')
    }
  }).listen(port, (err) => {
    if (err) throw err
    console.log(`> Ready on http://${hostname}:${port}`)
  })
})

server.js

// Supprt HTTPS
const fs = require('fs');
const path = require('path');
const https = require('https');
const cert = fs.readFileSync(path.join(__dirname,'../../path/bundle.crt'));
const key = fs.readFileSync(path.join(__dirname,'../../path/ca.key'));
const options = {key: key, cert: cert };


app.prepare().then(() => {
    https.createServer(options, async (req, res) => {
        try {
            ...
        } catch (err) {
            console.error('Error occurred handling', req.url, err)
            res.statusCode = 500
            res.end('internal server error')
        }
    }).listen(port, (err) => {
        if (err) throw err
        console.log(`> Ready on https://${hostname}:${port}`)
    })
})

https://localhost:3000

https://{YOUR_IP}:3000

package.json

"scripts": {
  "dev": "node server.js",
  "start": "NODE_ENV=production node server.js"
}

module.exports = {
  useFileSystemPublicRoutes: false,
}

$ curl -sL https://rpm.nodesource.com/setup_14.x | sudo bash -
$ sudo yum install nodejs
$ node --version  #v14.16.1
$ npm --version   #6.14.12

$ sudo npm install pm2@latest -g

#into your `"fullstack-nextjs-app-template/"` folder directory.
$ cd /{your_directory}/fullstack-nextjs-app-template


#run app
$ pm2 start ecosystem.config.js

#other commands
$ pm2 restart ecosystem.config.js
$ pm2 stop ecosystem.config.js
$ pm2 delete ecosystem.config.js
$ pm2 list
$ pm2 logs

$ pm2 start npm --name "fullstack-nextjs-app-template" -- start

$ pm2 stop "fullstack-nextjs-app-template" & pm2 delete "fullstack-nextjs-app-template"

$ pm2 startup
$ systemctl status pm2-root
$ pm2 start /{your_directory}/fullstack-nextjs-app-template/ecosystem.config.js --restart-delay=3000
$ pm2 save

build

dev

node_modules

$ npm i --force  # This can be ignored if you can build
$ rm -rf /{your_directory}/fullstack-nextjs-app-template/.next  # Delete the. Next folder
$ npm run build
$ pm2 start ecosystem.config.js

$ chmod -R a+x node_modules

export NODE_OPTIONS=--max_old_space_size=4096

NPM

# re-install PM2 (optional)
$ sudo npm i -g pm2   

# if pm2 was reinstalled, ts-node must be reinstalled (optional)
$ sudo npm install -g ts-node@latest  

# clear all pm2 instances
$ pm2 kill

# then restart it
$ pm2 start xxxxxx

$ sudo apt update
$ sudo apt install nginx

$ sudo yum install nginx -y

$ systemctl start nginx

$ systemctl enable nginx

$ firewall-cmd --permanent --zone=public --add-service=http
$ firewall-cmd --permanent --zone=public --add-service=https
$ firewall-cmd --permanent --zone=public --add-port=3000/tcp
$ firewall-cmd --reload
$ systemctl restart nginx 

$ systemctl status nginx

/etc/nginx/conf.d/default.conf

$ vi /etc/nginx/conf.d/default.conf

server {
        listen      443 ssl;
        server_name backend1.example.com;

        ...
        location / {
            proxy_set_header Host $http_host;
            proxy_pass http://{YOUR_IP}:3000;
        }

}

$ systemctl restart nginx

$ killall -9 node

pages/_document.tsx

<Head>

src/components/Header

"scripts": {
  "dev": "next -p 8080",
  "start": "next start -p 8080"
}

$ PORT=8080 npm run dev

next.config.js

scripts/config-rootdir-of-publishing-source.js

basePath

assetPrefix

public/

assets/

$ npm run action:rootdir

siteUrl

./src/data/app.json

{
    "siteUrl": "http://localhost:3000",
    "copyright": "xxxxxxxxxx"
}

getServerSideProps

Express

WebSocket

http://localhost:3000

http://localhost:7777

$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
$ sudo docker run hello-world

Dockerfile

$ cd /Applications/MAMP/htdocs/fullstack-nextjs-app-template
$ touch Dockerfile
$ vi Dockerfile

next.config.js

dockerDeploymentEnabled

true

next.config.js

// next.config.js
module.exports = {
     // ... rest of the configuration.
       output: 'standalone',
}

$ docker build -t fullstack-nextjs-app-template:v1 .

$ docker pull node:18.20.4-alpine3.20

docker run -p <host_port1>:<container_port1> -p <host_port2>:<container_port2>

$ docker run -p 3000:3000 fullstack-nextjs-app-template:v1

// Stop running node in docker with Ctrl+C sends the SIGINT signal.
// Usage: docker run --init -p <host_port>:<container_port> <image_name:version>
const process = require('process');
process.on('SIGINT', () => {
    console.info("Interrupted")
    process.exit(0);
});

$ docker run --init -p <host_port>:<container_port> <image_name:version>

$ docker run -p 3000:3000 -d fullstack-nextjs-app-template:v1

$ docker ps
$ docker stop <PID>
$ docker kill <PID>

#Query the process of port 3000
$ lsof -i tcp:3000

#PID is replaced by the id of the process
$ kill -9 <PID>

192.168.1.140

docker-registry

/var/lib/registry

docker run --name registry -d  -p 5000:5000 --restart=always  -v /Users/changcheng/Desktop/share:/var/lib/registry registry

5000

$ docker tag fullstack-nextjs-app-template:v1 192.168.1.140:5000/fullstack-nextjs-app-template-v1

$ docker push 192.168.1.140:5000/fullstack-nextjs-app-template-v1

registry-mirrors

insecure-registries

daemon.json

$ cat ~/.docker/daemon.json

{
    "registry-mirror":[
        "http://hub-mirror.c.163.com"
    ],
    "insecure-registries":[
        "192.168.1.140:5000"
    ]
}

$ docker pull 192.168.1.140:5000/fullstack-nextjs-app-template-v1

$ docker ps

docker commit <container_id> <image_name:version>

$ docker commit 16cb27979742 fullstack-nextjs-app-template:v1

docker save <image_name:version> -o <path_name>

$ docker save fullstack-nextjs-app-template:v1 -o ./fullstack-nextjs-app-template-v1.tar

Dockerfile

...

# A base image for the ARM architecture, such as the arm64 version of Node.js
FROM node:18.20.4-alpine3.20 AS base

...

$ docker build --platform linux/arm64 -t fullstack-nextjs-app-template-arm64:v1 .

$ docker buildx create --use
$ docker buildx build --platform linux/arm64 -t fullstack-nextjs-app-template-arm64:v1 .

docker buildx create --use

alpine

sharp

docker-compose.yml

services:
  web:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - my_node_service
  my_node_service:
    image: "my-node-server:v1"
    ports:
      - "4001:4001"

# build
$ docker build -t my-node-server:v1 .
# test
$ docker run --init -p 4001:4001 my-node-server:v1

$ docker-compose up

service.spec.sessionAffinity = "ClientIP"

socketIOClient(someUrl, {transports: ['websocket']});

./backend/server-socket.js

upgrade_configs: 
 upgrade_type: "websocket"

static_resources:
  listeners:
    - name: listener_0
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 8080
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                codec_type: AUTO  # Allow HTTP/1.1 and HTTP/2
                stat_prefix: ingress_http
                route_config:
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: "/"
                          route:
                            cluster: websocket_service
                            timeout: 0s  # Disable HTTP request timeout to ensure WebSocket long connection
                            upgrade_configs:
                              - upgrade_type: "websocket"  # Allow WebSocket
                http_filters:
                  - name: envoy.filters.http.router

  clusters:
    - name: websocket_service
      connect_timeout: 0.25s
      type: STATIC
      http2_protocol_options: {}  # Enable HTTP/2
      load_assignment:
        cluster_name: websocket_service
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: 127.0.0.1  # WebSocket server address
                      port_value: 5001  # WebSocket Server Port

const http = require('http');  // Use HTTP/1.1 instead of HTTP/2
const express = require('express');
const { Server } = require('socket.io');

const app = express();
const server = http.createServer(app);  // Make sure you use HTTP/1.1
const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

...

node_modules

npm run <script>

npx -p node@<version> <your_script>

$ npx -p node@15.14.0 npm run dev
$ npx -p node@14.21.3 npm run start

node_modules

npm install --legacy-peer-deps

$ npm install <package1> <package2> --legacy-peer-deps
$ npm install --save-dev <package1> <package2> --legacy-peer-deps

$ npm config get cache

$ npm cache clean --force

$ rm -rf ~/.npm

$ npm cache verify